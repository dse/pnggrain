/**
 * pnggrain
 *     generates pnggrain.png
 * pnggrain foo.png
 *     generates foo.png
 *
 * Thanks http://www.labbookpages.co.uk/software/imgProc/libPNG.html
 * for the example.
 */

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <png.h>
#include <zlib.h>
#include <time.h>
#include <string.h>

#include "pnggrain.h"

static pnggrain_options_s pnggrain_defaults = {
    .width     = 256,
    .height    = 256,
    .min_value = 0,
    .max_value = 255,
    .min_alpha = 0,
    .max_alpha = 255
};

int main(int argc, char **argv) {
    pnggrain_options_s pnggrain_options = pnggrain_defaults;
    char *filename = "pnggrain.png";
    int ch;
    while ((ch = getopt(argc, argv, "W:H:t:T:m:M:bdn?")) != -1) {
        switch (ch) {
        case 'W':
            pnggrain_options.width = atoi(optarg);
            break;
        case 'H':
            pnggrain_options.height = atoi(optarg);
            break;
        case 'm':
            pnggrain_options.min_value = atoi(optarg);
            break;
        case 'M':
            pnggrain_options.max_value = atoi(optarg);
            break;
        case 't':
            pnggrain_options.min_alpha = atoi(optarg);
            break;
        case 'T':
            pnggrain_options.max_alpha = atoi(optarg);
            break;
        case 'b':
            pnggrain_options.min_value = 255;
            pnggrain_options.max_value = 255;
            break;
        case 'd':
            pnggrain_options.min_value = 0;
            pnggrain_options.max_value = 0;
            break;
        case 'n':
            pnggrain_options.min_alpha = 255;
            pnggrain_options.max_alpha = 255;
            break;
        case 'h':
        case '?':
        default:
            usage();
            exit(0);
        }
    }
    argc -= optind;
    argv += optind;
    if (argc) {
        filename = argv[0];
    }
    pnggrain_generate(pnggrain_options, filename);
}

int pnggrain_generate(pnggrain_options_s pnggrain_options,
                      char *filename) {
    int code = 0;
    FILE *fp = NULL;
    png_structp png_ptr = NULL;
    png_infop info_ptr = NULL;
    png_bytep row = NULL;

    if (!strcmp(filename, "-")) {
        fp = stdout;
    } else {
        fp = fopen(filename, "wb");
        if (fp == NULL) {
            fprintf(stderr, "Could not open file %s for writing\n", filename);
            code = 1;
            goto finalise;
        }
    }

    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (png_ptr == NULL) {
        fprintf(stderr, "Could not allocate write struct\n");
        code = 1;
        goto finalise;
    }

    info_ptr = png_create_info_struct(png_ptr);
    if (info_ptr == NULL) {
        fprintf(stderr, "Could not allocate info struct\n");
        code = 1;
        goto finalise;
    }

    if (setjmp(png_jmpbuf(png_ptr))) {
        fprintf(stderr, "Error during png creation\n");
        code = 1;
        goto finalise;
    }

    png_init_io(png_ptr, fp);
    png_set_IHDR(png_ptr,
                 info_ptr,
                 pnggrain_options.width,
                 pnggrain_options.height,
                 8,             /* bit depth of each channel */
                 PNG_COLOR_TYPE_GRAY_ALPHA,
                 PNG_INTERLACE_NONE,
                 PNG_COMPRESSION_TYPE_DEFAULT,
                 PNG_FILTER_TYPE_BASE);
    png_set_compression_strategy(png_ptr, Z_DEFAULT_STRATEGY);
    png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);

    png_text title_text;
    title_text.compression = PNG_TEXT_COMPRESSION_NONE;
    title_text.key = "Title";
    title_text.text = "image generated by pnggrain";
    png_set_text(png_ptr, info_ptr, &title_text, 1);

    png_write_info(png_ptr, info_ptr);

    row = (png_bytep) malloc(2 * pnggrain_options.width * sizeof(png_byte));

    srand(time(NULL) + getpid() * 23);

    int x, y;
    for (y = 0; y < pnggrain_options.height; y += 1) {
        for (x = 0; x < pnggrain_options.width; x += 1) {
            int value = random_value(pnggrain_options.min_value, pnggrain_options.max_value);
            int alpha = random_value(pnggrain_options.min_alpha, pnggrain_options.max_alpha);
            row[x * 2]     = value;
            row[x * 2 + 1] = alpha;
        }
        png_write_row(png_ptr, row);
    }
    png_write_end(png_ptr, NULL);

 finalise:
    if (fp != NULL) {
        fclose(fp);
    }
    if (info_ptr != NULL) {
        png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
    }
    if (png_ptr != NULL) {
        png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
    }
    if (row != NULL) {
        free(row);
    }
    return code;
}

int random_value(int from, int to) {
    if (from == to) {
        return from;
    }
    if (from > to) {
        return (int)(
            to + 1.0 * (from - to + 1) * rand() / RAND_MAX
        );
    }
    return (int)(
        from + 1.0 * (to - from + 1) * rand() / RAND_MAX
    );
}

void print_pnggrain_options(pnggrain_options_s pnggrain_options, FILE *fp) {
    fputs("pnggrain_options(", fp);
    fprintf(fp, "width %d", pnggrain_options.width);
    fprintf(fp, "; height %d", pnggrain_options.height);
    if (pnggrain_options.min_alpha == pnggrain_options.max_alpha) {
        fprintf(fp, "; alpha %d", pnggrain_options.min_alpha);
    } else {
        fprintf(fp, "; alpha from %d to %d", pnggrain_options.min_alpha, pnggrain_options.max_alpha);
    }
    if (pnggrain_options.min_value == pnggrain_options.max_value) {
        fprintf(fp, "; value %d", pnggrain_options.min_value);
    } else {
        fprintf(fp, "; value from %d to %d", pnggrain_options.min_value, pnggrain_options.max_value);
    }
    fputs(")\n", fp);
}

void usage(void) {
    puts("usage: pnggrain [<option> ...] [<filename>]");
    puts("options:");
    puts("    -W <int>    specify image width (default 256)");
    puts("    -H <int>    specify image height (default 256)");
    puts("    -t <int>    min alpha (0 to 255)");
    puts("    -T <int>    max alpha (0 to 255)");
    puts("    -m <int>    min value (0 to 255)");
    puts("    -M <int>    max value (0 to 255)");
    puts("    -n          no transparency");
    puts("    -b          bright pixels only");
    puts("    -d          dark pixels only");
    puts("    -h, -?      display this message");
}
